{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Clustr Documentation","text":"<p>Clustr is an end-to-end retail intelligence platform that simulates retail environments, processes data through a structured ETL pipeline, performs association-rule and ML-driven bundle recommendations, and presents insights through a FastAPI backend and Streamlit interface.</p> <p>This documentation provides a complete overview of the system, including data generation, database structures, API specifications, ML logic, and user interface features.</p>"},{"location":"#overview","title":"Overview","text":"<p>Clustr includes the following major components:</p> <ul> <li> <p>ETL Layer   Generates and loads synthetic retail datasets into PostgreSQL.</p> </li> <li> <p>API Layer (FastAPI)   Provides CRUD endpoints, analytics, and ML-based recommendations.</p> </li> <li> <p>Frontend (Streamlit)   An interface for dashboards, product bundles, campaigns, and database exploration.</p> </li> <li> <p>ML Engine   Generates predictive bundle recommendations based on customer segmentation and historical patterns.</p> </li> <li> <p>Documentation (MkDocs)   Full project documentation for developers and analysts.</p> </li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<p>Clustr is composed of:</p> <ul> <li>A PostgreSQL database for structured master and fact tables  </li> <li>SQLAlchemy ORM models matching the API and ETL schemas  </li> <li>FastAPI service layer powering bundle recommendations  </li> <li>Streamlit app for business users  </li> <li>ETL pipeline to keep data consistent and reproducible  </li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>API \u2013 Endpoints, schemas, example responses  </li> <li>ETL \u2013 Data generation and loading workflow  </li> <li>App \u2013 Streamlit UI and features  </li> <li>Models \u2013 ORM and Pydantic schemas  </li> <li>Demo \u2013 Step-by-step usage guide  </li> </ul> <p>Each section is designed for clarity and professional readability.</p>"},{"location":"api/","title":"API \u2013 Clustr Backend","text":"<p>The Clustr backend is implemented with FastAPI and exposes REST endpoints for accessing master data, transactional data, association rules, and ML-based bundle recommendations.</p> <p>Base URL in local development:</p> <pre><code>http://127.0.0.1:8008\n</code></pre> <p>Interactive API docs (Swagger UI):</p> <pre><code>http://127.0.0.1:8008/docs\n</code></pre>"},{"location":"api/#1-base-endpoints","title":"1. Base Endpoints","text":""},{"location":"api/#get","title":"GET /","text":"<p>Returns a simple JSON payload confirming that the service is running.</p> <p>Example response:</p> <pre><code>{\n  \"service\": \"Clustr API\",\n  \"status\": \"ok\"\n}\n</code></pre>"},{"location":"api/#get-health","title":"GET /health","text":"<p>Checks that the API and database are reachable.</p> <p>Example response:</p> <pre><code>{\n  \"status\": \"ok\"\n}\n</code></pre>"},{"location":"api/#2-product-endpoints","title":"2. Product Endpoints","text":"<p>These endpoints work with the <code>products</code> table and corresponding Pydantic schemas.</p>"},{"location":"api/#get-apiproducts","title":"GET /api/products/","text":"<p>Returns all products.</p> <p>Fields:</p> <ul> <li>product_sku  </li> <li>product_name  </li> <li>category  </li> <li>brand  </li> <li>price  </li> </ul>"},{"location":"api/#post-apiproducts","title":"POST /api/products/","text":"<p>Creates a new product.</p> <p>Request body (conceptual structure):</p> <ul> <li>product_name  </li> <li>category  </li> <li>brand  </li> <li>price  </li> </ul> <p>Example request:</p> <pre><code>{\n  \"product_name\": \"Moisturizer X\",\n  \"category\": \"Skincare\",\n  \"brand\": \"FreshLine\",\n  \"price\": 19.99\n}\n</code></pre> <p>Response:</p> <ul> <li>Returns the created product, including its <code>product_sku</code>.</li> </ul>"},{"location":"api/#3-customer-endpoints","title":"3. Customer Endpoints","text":"<p>These endpoints work with the <code>customers</code> table.</p>"},{"location":"api/#get-apicustomers","title":"GET /api/customers/","text":"<p>Returns all customers.</p> <p>Fields:</p> <ul> <li>customer_id  </li> <li>first_name  </li> <li>last_name  </li> <li>gender  </li> <li>age  </li> <li>dob  </li> <li>email  </li> <li>phone  </li> <li>city  </li> <li>income_level  </li> <li>shopping_preference  </li> <li>customer_segment  </li> </ul>"},{"location":"api/#post-apicustomers","title":"POST /api/customers/","text":"<p>Creates a new customer.</p> <p>Request body (conceptual structure):</p> <ul> <li>first_name  </li> <li>last_name  </li> <li>gender  </li> <li>age  </li> <li>dob  </li> <li>email  </li> <li>phone  </li> <li>city  </li> <li>income_level  </li> <li>shopping_preference  </li> <li>customer_segment  </li> </ul> <p>Response:</p> <ul> <li>Returns the created customer, including <code>customer_id</code>.</li> </ul>"},{"location":"api/#4-timeframe-endpoints","title":"4. Timeframe Endpoints","text":"<p>The <code>timeframe</code> table stores calendar information for analytics.</p>"},{"location":"api/#get-apitimeframe","title":"GET /api/timeframe/","text":"<p>Returns all timeframe rows.</p> <p>Fields:</p> <ul> <li>time_id  </li> <li>date  </li> <li>day  </li> <li>month  </li> <li>year  </li> </ul>"},{"location":"api/#post-apitimeframe","title":"POST /api/timeframe/","text":"<p>Creates a new timeframe record.</p> <p>Request body (conceptual structure):</p> <ul> <li>date  </li> <li>day  </li> <li>month  </li> <li>year  </li> </ul> <p>Response:</p> <ul> <li>Returns the created timeframe entry.</li> </ul>"},{"location":"api/#5-transaction-endpoints","title":"5. Transaction Endpoints","text":"<p>Transactions represent a completed purchase made by a customer at a specific time.</p>"},{"location":"api/#get-apitransactions","title":"GET /api/transactions/","text":"<p>Returns all transactions.</p> <p>Fields:</p> <ul> <li>transaction_id  </li> <li>customer_id  </li> <li>time_id  </li> <li>transaction_amount  </li> <li>channel  </li> <li>payment_type  </li> </ul>"},{"location":"api/#post-apitransactions","title":"POST /api/transactions/","text":"<p>Creates a new transaction.</p> <p>Request body (conceptual structure):</p> <ul> <li>customer_id  </li> <li>time_id  </li> <li>transaction_amount  </li> <li>channel  </li> <li>payment_type  </li> </ul> <p>Response:</p> <ul> <li>Returns the created transaction, including <code>transaction_id</code>.</li> </ul>"},{"location":"api/#6-sales-endpoints","title":"6. Sales Endpoints","text":"<p>Sales are line items within a transaction, each referring to a specific product.</p>"},{"location":"api/#get-apisales","title":"GET /api/sales/","text":"<p>Returns all sales line items.</p> <p>Fields:</p> <ul> <li>sale_id  </li> <li>transaction_id  </li> <li>product_sku  </li> <li>quantity  </li> <li>unit_price  </li> <li>line_total  </li> </ul>"},{"location":"api/#post-apisales","title":"POST /api/sales/","text":"<p>Creates a new sales line item.</p> <p>Request body (conceptual structure):</p> <ul> <li>transaction_id  </li> <li>product_sku  </li> <li>quantity  </li> <li>unit_price  </li> </ul> <p>Response:</p> <ul> <li>Returns the created sale, including <code>sale_id</code> and computed <code>line_total</code> where applicable.</li> </ul>"},{"location":"api_models/","title":"Clustr API Models","text":"<p>Clustr uses a unified data model shared across the ETL layer, API layer, ML engine, and Streamlit application. This document describes all ORM (SQLAlchemy) models and Pydantic schemas used by the FastAPI backend to validate requests and structure responses.</p> <p>All model definitions are located in:</p> <ul> <li><code>api/Database/models.py</code> \u2014 SQLAlchemy ORM tables  </li> <li><code>api/Database/schema.py</code> \u2014 Pydantic request/response models  </li> </ul> <p>The goal is to ensure consistent structure across all layers of the Clustr ecosystem.</p>"},{"location":"api_models/#1-product-models","title":"1. Product Models","text":"<p>Products represent individual catalog items.</p>"},{"location":"api_models/#orm-model-fields","title":"ORM Model Fields","text":"<ul> <li>product_sku  </li> <li>product_name  </li> <li>category  </li> <li>brand  </li> <li>price  </li> </ul>"},{"location":"api_models/#pydantic-schemas","title":"Pydantic Schemas","text":"<ul> <li>ProductBase \u2013 shared fields  </li> <li>ProductCreate \u2013 used for POST requests  </li> <li>Product \u2013 returned in GET responses (includes <code>product_sku</code>)  </li> </ul> <p>Example conceptual structure:</p> <pre><code>Product:\n  product_sku: int\n  product_name: str\n  category: str\n  brand: str\n  price: float\n</code></pre>"},{"location":"api_models/#2-customer-models","title":"2. Customer Models","text":"<p>Customers contain demographic, segmentation, and contact details.</p>"},{"location":"api_models/#orm-model-fields_1","title":"ORM Model Fields","text":"<ul> <li>customer_id  </li> <li>first_name  </li> <li>last_name  </li> <li>gender  </li> <li>age  </li> <li>dob  </li> <li>email  </li> <li>phone  </li> <li>city  </li> <li>income_level  </li> <li>shopping_preference  </li> <li>customer_segment  </li> </ul>"},{"location":"api_models/#pydantic-schemas_1","title":"Pydantic Schemas","text":"<ul> <li>CustomerBase </li> <li>CustomerCreate </li> <li>Customer </li> </ul> <p><code>CustomerCreate</code> excludes <code>customer_id</code>, while <code>Customer</code> includes it.</p> <p>Conceptual structure:</p> <pre><code>Customer:\n  customer_id: int\n  first_name: str\n  last_name: str\n  gender: str\n  age: int\n  email: str\n  city: str\n  income_level: str\n  shopping_preference: str\n  customer_segment: str\n</code></pre>"},{"location":"api_models/#3-timeframe-models","title":"3. Timeframe Models","text":"<p>Timeframe represents individual dates used for analytics and joins.</p>"},{"location":"api_models/#orm-model-fields_2","title":"ORM Model Fields","text":"<ul> <li>time_id  </li> <li>date  </li> <li>day  </li> <li>month  </li> <li>year  </li> </ul>"},{"location":"api_models/#pydantic-schemas_2","title":"Pydantic Schemas","text":"<ul> <li>TimeframeBase </li> <li>TimeframeCreate </li> <li>Timeframe </li> </ul> <p>Example shape:</p> <pre><code>Timeframe:\n  time_id: int\n  date: YYYY-MM-DD\n  day: int\n  month: int\n  year: int\n</code></pre>"},{"location":"api_models/#4-transaction-models","title":"4. Transaction Models","text":"<p>Transactions represent purchases made by customers.</p>"},{"location":"api_models/#orm-model-fields_3","title":"ORM Model Fields","text":"<ul> <li>transaction_id  </li> <li>customer_id  </li> <li>time_id  </li> <li>transaction_amount  </li> <li>channel  </li> <li>payment_type  </li> </ul>"},{"location":"api_models/#pydantic-schemas_3","title":"Pydantic Schemas","text":"<ul> <li>TransactionBase </li> <li>TransactionCreate </li> <li>Transaction </li> </ul> <p>Example structure:</p> <pre><code>Transaction:\n  transaction_id: int\n  customer_id: int\n  time_id: int\n  transaction_amount: float\n  channel: str\n  payment_type: str\n</code></pre>"},{"location":"api_models/#5-sales-line-item-models","title":"5. Sales (Line Item) Models","text":"<p>Sales correspond to individual products within a transaction.</p>"},{"location":"api_models/#orm-model-fields_4","title":"ORM Model Fields","text":"<ul> <li>sale_id  </li> <li>transaction_id  </li> <li>product_sku  </li> <li>quantity  </li> <li>unit_price  </li> <li>line_total  </li> </ul>"},{"location":"api_models/#pydantic-schemas_4","title":"Pydantic Schemas","text":"<ul> <li>SaleBase </li> <li>SaleCreate </li> <li>Sale </li> </ul> <p>Conceptual structure:</p> <pre><code>Sale:\n  sale_id: int\n  transaction_id: int\n  product_sku: int\n  quantity: int\n  unit_price: float\n  line_total: float\n</code></pre>"},{"location":"api_models/#6-association-rule-models-bundle-rules","title":"6. Association Rule Models (Bundle Rules)","text":"<p>Association rules represent baseline product bundles derived from market-basket analysis.</p>"},{"location":"api_models/#orm-model-fields_5","title":"ORM Model Fields","text":"<ul> <li>rule_id  </li> <li>antecedents  </li> <li>consequents  </li> <li>support  </li> <li>confidence  </li> <li>lift  </li> <li>count_a  </li> <li>count_b  </li> </ul>"},{"location":"api_models/#pydantic-schema","title":"Pydantic Schema","text":"<ul> <li>BundleRule </li> </ul> <p>Conceptual structure:</p> <pre><code>BundleRule:\n  rule_id: int\n  antecedents: list\n  consequents: list\n  support: float\n  confidence: float\n  lift: float\n</code></pre> <p>These rules are served through <code>/api/bundles/association-rules/</code>.</p>"},{"location":"api_models/#7-ml-bundle-recommendation-models","title":"7. ML Bundle Recommendation Models","text":"<p>The ML engine generates enhanced bundle recommendations. These are not stored in the database but returned as response objects.</p>"},{"location":"api_models/#fields-returned-by-the-ml-model","title":"Fields Returned by the ML Model","text":"<ul> <li>bundle (list of items)  </li> <li>support  </li> <li>confidence  </li> <li>lift  </li> <li>score (ML prediction score)  </li> </ul> <p>Example structure:</p> <pre><code>MLBundleRecommendation:\n  bundle: list\n  score: float\n  confidence: float\n  lift: float\n  support: float\n</code></pre> <p>These models are used in <code>/api/bundles/recommendations/</code>.</p>"},{"location":"api_models/#8-model-consistency-across-clustr","title":"8. Model Consistency Across Clustr","text":"<p>All ETL, backend, ML, and Streamlit layers use the same schema conventions:</p> <ul> <li>Consistent column names  </li> <li>Aligned data types  </li> <li>Centralized definitions  </li> <li>Safe request/response validation  </li> <li>Reusable ORM models  </li> </ul> <p>This provides stability and prevents mismatches between layers.</p>"},{"location":"api_models/#summary","title":"Summary","text":"<p>The Clustr API models define:</p> <ul> <li>how data is stored  </li> <li>how data is sent and received  </li> <li>how ML predictions are structured  </li> </ul> <p>These unified models enable Clustr to operate as a coherent, reliable system across the ETL, API, ML, and front-end layers.</p>"},{"location":"app/","title":"Clustr Application (Streamlit UI)","text":"<p>The Clustr Streamlit application is the main user-facing interface for analysts and marketers. It provides dashboards, database exploration tools, segmentation filters, and product bundle recommendations powered by both association rules and machine learning.</p> <p>All application-related code is stored in the <code>app/</code> directory.</p>"},{"location":"app/#1-application-structure","title":"1. Application Structure","text":"<p>The Streamlit application is organized into multiple modular pages:</p> <ul> <li>Login \u2013 authentication and session initialization  </li> <li>Dashboard \u2013 high-level KPIs, visual analytics, and customer insights  </li> <li>Database \u2013 exploration of PostgreSQL tables  </li> <li>Bundles \u2013 association-rule and ML-based bundle discovery  </li> <li>Campaigns \u2013 create campaign concepts based on selected bundles  </li> <li>Settings \u2013 configure user and application preferences  </li> </ul>"},{"location":"app/#2-login-page","title":"2. Login Page","text":"<p>The login page provides simple session-based access control.</p> <p>Features:</p> <ul> <li>username and password fields  </li> <li>basic validation  </li> <li>session state management  </li> </ul> <p>After logging in, users can navigate freely across all app sections.</p>"},{"location":"app/#3-dashboard-page","title":"3. Dashboard Page","text":"<p>The dashboard provides visual summaries of the synthetic retail dataset loaded by the ETL pipeline.</p> <p>Typical insights displayed:</p> <ul> <li>total sales and revenue trends  </li> <li>top-performing products  </li> <li>customer demographics (age, gender, income level)  </li> <li>category and brand-level breakdowns  </li> <li>daily / monthly / yearly performance charts  </li> </ul> <p>This page helps orient analysts and provides a data-driven overview.</p>"},{"location":"app/#4-database-explorer","title":"4. Database Explorer","text":"<p>The Database page connects directly to PostgreSQL and allows users to inspect data tables.</p> <p>Capabilities:</p> <ul> <li>selectable table dropdown  </li> <li>preview of rows  </li> <li>column metadata  </li> <li>dynamic table refresh  </li> <li>scrollable, paginated content  </li> </ul> <p>It provides a simple way to validate ETL results or understand database structure.</p>"},{"location":"app/#5-bundles-page","title":"5. Bundles Page","text":"<p>The Bundles page is the core analytical section of the Clustr application.</p>"},{"location":"app/#filters-available","title":"Filters available:","text":"<ul> <li>gender  </li> <li>age range  </li> <li>income level  </li> <li>customer segment  </li> <li>shopping preference  </li> </ul>"},{"location":"app/#outputs-displayed","title":"Outputs displayed:","text":"<ul> <li>association-rule bundles from the <code>bundle_rules</code> table  </li> <li>ML-recommended bundles, ranked by predicted success score  </li> </ul> <p>Each bundle includes:</p> <ul> <li>bundle items (antecedents + consequents)  </li> <li>support  </li> <li>confidence  </li> <li>lift  </li> <li>ML score (if using the prediction model)  </li> </ul> <p>This page empowers marketers to identify high-value product combinations.</p>"},{"location":"app/#6-campaigns-page","title":"6. Campaigns Page","text":"<p>The Campaigns page helps convert insights into actionable ideas.</p> <p>It allows the user to:</p> <ul> <li>select a recommended bundle  </li> <li>target a specific customer segment  </li> <li>generate messaging suggestions  </li> <li>outline promotional strategies  </li> </ul> <p>This bridges analytics with practical marketing execution.</p>"},{"location":"app/#7-settings-page","title":"7. Settings Page","text":"<p>The Settings page supports configuration options for Clustr.</p> <p>Possible settings:</p> <ul> <li>number of bundles to display  </li> <li>ML threshold sensitivity  </li> <li>UI configuration options  </li> <li>demo mode toggles  </li> </ul> <p>These settings help customize the user experience.</p>"},{"location":"app/#8-api-database-connectivity","title":"8. API &amp; Database Connectivity","text":"<p>The Streamlit application interacts with:</p>"},{"location":"app/#fastapi-backend","title":"FastAPI backend","text":"<p>Used for:</p> <ul> <li>fetching master and transactional data  </li> <li>retrieving association rules  </li> <li>fetching ML-based recommendations  </li> </ul>"},{"location":"app/#postgresql-database","title":"PostgreSQL database","text":"<p>Used for:</p> <ul> <li>direct table inspection  </li> <li>validating ETL-loaded data  </li> </ul> <p>This dual-access strategy ensures both operational reliability and debugging flexibility.</p>"},{"location":"app/#9-running-the-app","title":"9. Running the App","text":"<p>To launch the Streamlit UI:</p> <pre><code>streamlit run app/app.py\n</code></pre> <p>The application will be available at:</p> <pre><code>http://localhost:8501\n</code></pre> <p>Users must log in before accessing other pages.</p>"},{"location":"app/#10-role-of-the-streamlit-app-in-the-clustr-ecosystem","title":"10. Role of the Streamlit App in the Clustr Ecosystem","text":"<p>The app serves as the primary interface for non-technical users.</p> <p>It enables:</p> <ul> <li>intuitive data visualization  </li> <li>interactive segmentation filtering  </li> <li>real-time ML bundle recommendation exploration  </li> <li>campaign planning based on bundle insights  </li> </ul> <p>Clustr\u2019s architecture ensures that the Streamlit UI always reflects the latest ETL-loaded and API-exposed data.</p>"},{"location":"app/#11-summary","title":"11. Summary","text":"<p>The Clustr Streamlit application provides a complete analytical experience, allowing users to:</p> <ul> <li>explore generated retail datasets  </li> <li>visualize customer behavior  </li> <li>analyze product performance  </li> <li>discover high-value product bundles  </li> <li>plan marketing campaigns  </li> </ul> <p>This interactive layer makes Clustr accessible, practical, and impactful for end-users.</p>"},{"location":"demo/","title":"Clustr Demo Guide","text":"<p>This demo guide explains how to run Clustr from end to end \u2014 starting the ETL pipeline, launching the backend API, opening the Streamlit app, and exploring bundle recommendations. It is designed to help developers, analysts, and reviewers quickly understand and operate the system.</p>"},{"location":"demo/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before running Clustr, ensure that the following tools are installed:</p> <ul> <li>Python  </li> <li>PostgreSQL (or use dockerized version if configured)  </li> <li>Required Python dependencies (install via requirements file if provided)  </li> </ul> <p>Additionally, verify that your database connection settings are correctly configured in environment variables or your application settings.</p>"},{"location":"demo/#2-run-the-etl-pipeline","title":"2. Run the ETL Pipeline","text":"<p>The ETL pipeline generates a full synthetic retail dataset and loads it into PostgreSQL.</p> <p>From the project root, run:</p> <pre><code>python etl/etl_process.py\n</code></pre> <p>This script performs the following:</p> <ol> <li>Generates synthetic customers, products, timeframe, transactions, and sales.  </li> <li>Saves all CSV files to <code>etl/data/raw/</code>.  </li> <li>Creates database tables using SQLAlchemy models.  </li> <li>Loads all CSVs into PostgreSQL.  </li> <li>Generates association rules and loads them into the <code>bundle_rules</code> table.  </li> </ol> <p>When complete, the database will contain all data required for Clustr to operate.</p>"},{"location":"demo/#3-start-the-fastapi-backend","title":"3. Start the FastAPI Backend","text":"<p>The backend exposes all API routes, including CRUD endpoints, association-rule outputs, and ML-based bundle recommendations.</p> <p>Run:</p> <pre><code>uvicorn api.main:app --reload\n</code></pre> <p>This will start the backend at:</p> <pre><code>http://127.0.0.1:8000\n</code></pre> <p>Swagger UI (interactive documentation):</p> <pre><code>http://127.0.0.1:8000/docs\n</code></pre> <p>You can use Swagger to:</p> <ul> <li>Inspect endpoints  </li> <li>Send test requests  </li> <li>View response structures  </li> <li>Validate database content  </li> </ul>"},{"location":"demo/#4-start-the-streamlit-application","title":"4. Start the Streamlit Application","text":"<p>The Streamlit UI provides dashboards, customer insights, bundle discovery, and campaign tools.</p> <p>Run:</p> <pre><code>streamlit run app/app.py\n</code></pre> <p>Then open:</p> <pre><code>http://localhost:8501\n</code></pre> <p>Pages available:</p> <ul> <li>Dashboard \u2013 visual insights on sales and customer segments  </li> <li>Database \u2013 browse tables loaded in PostgreSQL  </li> <li>Bundles \u2013 view association-rule and ML-based product bundles  </li> <li>Campaigns \u2013 convert bundles into marketing ideas  </li> <li>Settings \u2013 adjust app preferences  </li> </ul> <p>This interface is designed for analysts and marketing users.</p>"},{"location":"demo/#5-explore-the-database-optional","title":"5. Explore the Database (Optional)","text":"<p>If using pgAdmin or another SQL tool, you may explore the generated tables:</p> <ul> <li>products  </li> <li>customers  </li> <li>timeframe  </li> <li>transactions  </li> <li>sales  </li> <li>bundle_rules  </li> </ul> <p>pgAdmin (if running in Docker):</p> <pre><code>http://localhost:5051\n</code></pre> <p>This is useful for verifying ETL results or validating API behavior.</p>"},{"location":"demo/#6-explore-bundle-recommendations","title":"6. Explore Bundle Recommendations","text":"<p>One of the core features of Clustr is recommending product bundles.</p> <p>You can explore bundles using:</p>"},{"location":"demo/#streamlit-bundles-page","title":"Streamlit Bundles Page","text":"<p>Provides filters for:</p> <ul> <li>gender  </li> <li>age range  </li> <li>income level  </li> <li>customer segment  </li> <li>shopping preferences  </li> </ul> <p>Outputs include:</p> <ul> <li>association-rule bundles  </li> <li>ML bundle predictions (with score rankings)  </li> </ul>"},{"location":"demo/#7-full-system-workflow-summary","title":"7. Full System Workflow Summary","text":"<p>The Clustr workflow works as follows:</p> <ol> <li> <p>ETL    Generates and loads all retail data into PostgreSQL.</p> </li> <li> <p>Backend (FastAPI)    Serves data and provides ML-powered bundle recommendations.</p> </li> <li> <p>Frontend (Streamlit)    Allows users to visualize insights and build marketing bundles.</p> </li> <li> <p>ML Engine    Scores bundles and powers the recommendation system.</p> </li> </ol>"},{"location":"demo/#8-conclusion","title":"8. Conclusion","text":"<p>Clustr provides an integrated environment for:</p> <ul> <li>data generation  </li> <li>storage  </li> <li>analytics  </li> <li>machine learning  </li> <li>visualization  </li> </ul> <p>This demo guide helps you navigate and operate the full system smoothly.</p>"},{"location":"etl/","title":"ETL \u2013 Clustr Data Generation and Loading Pipeline","text":"<p>The ETL layer in Clustr is responsible for generating a synthetic retail dataset, creating the database schema, loading data into PostgreSQL, and preparing baseline association-rule bundles.</p> <p>All ETL-related code is located in the <code>etl/</code> directory.</p>"},{"location":"etl/#1-etl-structure","title":"1. ETL Structure","text":"<p>Main components:</p> <ul> <li><code>simulate_data.py</code> \u2013 synthetic data generator  </li> <li><code>etl_process.py</code> \u2013 ETL orchestrator script  </li> <li><code>Database/models.py</code> \u2013 SQLAlchemy ORM models  </li> <li><code>Database/load_data.py</code> \u2013 CSV loading utilities  </li> <li><code>data/raw/</code> \u2013 folder where generated CSVs are stored  </li> </ul> <p>This pipeline ensures that all layers (ETL, API, ML, Streamlit UI) operate on the same clean and consistent data.</p>"},{"location":"etl/#2-synthetic-data-generation-simulate_datapy","title":"2. Synthetic Data Generation (<code>simulate_data.py</code>)","text":"<p>The synthetic data generator creates a realistic retail-style dataset. It produces:</p> <ul> <li>Customers  </li> <li>Products  </li> <li>Timeframe (daily dates)  </li> <li>Transactions  </li> <li>Sales line items  </li> </ul> <p>All generated CSV files are stored in:</p> <pre><code>etl/data/raw/\n</code></pre> <p>Typical configuration parameters inside the script include:</p> <ul> <li>number of customers  </li> <li>number of products  </li> <li>number of days  </li> <li>total number of transactions  </li> <li>maximum number of line items per transaction  </li> </ul> <p>Output CSV files:</p> <ul> <li><code>customers.csv</code> </li> <li><code>products.csv</code> </li> <li><code>timeframe.csv</code> </li> <li><code>transactions.csv</code> </li> <li><code>sales.csv</code> </li> </ul> <p>The data is internally consistent:</p> <ul> <li>Each transaction references an existing customer and a timeframe date.  </li> <li>Each sale references both a transaction and a product.  </li> </ul>"},{"location":"etl/#3-database-schema-databasemodelspy","title":"3. Database Schema (<code>Database/models.py</code>)","text":"<p>The ETL layer defines ORM models using SQLAlchemy that mirror the structure used by the API layer.</p> <p>Core tables:</p> <ul> <li><code>products</code> </li> <li><code>customers</code> </li> <li><code>timeframe</code> </li> <li><code>transactions</code> </li> <li><code>sales</code> </li> <li><code>bundle_rules</code> </li> </ul> <p>These models are used to:</p> <ul> <li>Create tables in PostgreSQL before loading data.  </li> <li>Ensure column names and types are consistent between ETL and API.  </li> </ul> <p>This shared schema design guarantees that:</p> <ul> <li>ETL can load data without schema mismatches.  </li> <li>FastAPI can query and serve the same tables directly.  </li> </ul>"},{"location":"etl/#4-csv-loading-utilities-databaseload_datapy","title":"4. CSV Loading Utilities (<code>Database/load_data.py</code>)","text":"<p>This module contains helper functions for loading CSV files into PostgreSQL using pandas and SQLAlchemy.</p> <p>Typical responsibilities:</p> <ul> <li>Open a database connection.  </li> <li>Optionally truncate a table before inserting new data.  </li> <li>Load CSV data from <code>data/raw/</code>.  </li> <li>Write data into the matching table.  </li> </ul> <p>Common conceptual operations:</p> <ul> <li> <p>Truncate a table before reloading:</p> <p>truncate_table(\"customers\")</p> </li> <li> <p>Load a specific entity:</p> <p>load_customers()   load_products()   load_timeframe()   load_transactions()   load_sales()</p> </li> </ul> <p>The goal of this module is to provide a clear, reusable interface for loading each part of the dataset.</p>"},{"location":"etl/#5-baseline-association-rules","title":"5. Baseline Association Rules","text":"<p>In addition to raw transactional data, Clustr needs baseline product bundles derived from classic market-basket analysis.</p> <p>The ETL process:</p> <ol> <li>Runs association-rule mining on historical transaction data.  </li> <li>Produces an output CSV, for example: <code>baseline_rules.csv</code>.  </li> <li>Loads the resulting rules into the <code>bundle_rules</code> table.  </li> </ol> <p>Each rule typically contains:</p> <ul> <li>antecedents  </li> <li>consequents  </li> <li>support  </li> <li>confidence  </li> <li>lift  </li> <li>counts for the involved products  </li> </ul>"},{"location":"etl/#6-etl-orchestrator-etl_processpy","title":"6. ETL Orchestrator (<code>etl_process.py</code>)","text":"<p>The script <code>etl_process.py</code> coordinates all ETL steps and can be run to fully refresh the database.</p> <p>High-level workflow:</p> <ol> <li>Create database schema </li> <li> <p>Uses SQLAlchemy models to create missing tables.</p> </li> <li> <p>Generate synthetic data </p> </li> <li> <p>Calls <code>simulate_data.py</code> logic, if CSVs are missing or regeneration is needed.</p> </li> <li> <p>Load master and fact tables </p> </li> <li> <p>Loads products, customers, timeframe, transactions, and sales from CSVs.</p> </li> <li> <p>Generate association rules </p> </li> <li> <p>Runs association-rule mining over the transactional data.</p> </li> <li> <p>Load bundle rules </p> </li> <li>Inserts the resulting rules into the <code>bundle_rules</code> table.</li> </ol> <p>Running this script ensures that the Clustr environment always has fresh data ready for analysis, dashboards, and ML inference.</p>"},{"location":"etl/#7-running-the-etl-pipeline","title":"7. Running the ETL Pipeline","text":"<p>A typical development workflow:</p> <ol> <li>Make sure PostgreSQL is running and accessible.  </li> <li>Configure the database connection string (for example, via environment variables).  </li> <li> <p>From the project root, run:</p> <p>python etl/etl_process.py</p> </li> </ol> <p>This will:</p> <ul> <li>Generate synthetic data (if needed).  </li> <li>Create tables (if they do not exist).  </li> <li>Load all core tables.  </li> <li>Populate the <code>bundle_rules</code> table with baseline association rules.  </li> </ul> <p>Once ETL finishes:</p> <ul> <li>The FastAPI backend can query all data.  </li> <li>The Streamlit app can display dashboards and bundles.  </li> <li>The ML engine can train or infer using the loaded dataset.  </li> </ul>"},{"location":"etl/#8-etl-in-the-overall-clustr-architecture","title":"8. ETL in the Overall Clustr Architecture","text":"<p>The ETL layer is the foundation for the entire Clustr platform:</p> <ul> <li>It feeds the database with structured master and fact tables.  </li> <li>It prepares association-rule bundles for immediate use.  </li> <li>It ensures there is always consistent, reproducible data available for:  </li> <li>API endpoints  </li> <li>ML models  </li> <li>Dashboards and segmentation views  </li> </ul> <p>By separating generation, loading, and rule creation into dedicated components, Clustr maintains a clear, maintainable pipeline that can be extended with real data sources in the future.</p>"}]}